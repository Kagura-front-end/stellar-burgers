import { configureStore, combineReducers, nanoid } from '@reduxjs/toolkit';
import {
  useDispatch as useReduxDispatch,
  useSelector as useReduxSelector,
  TypedUseSelectorHook,
} from 'react-redux';

import constructorReducer from './constructor/constructor.slice';
import ingredientsReducer from './ingredients/ingredients.slice';
import { publicOrdersReducer } from './orders/publicOrders.slice';
import { userOrdersReducer } from './orders/userOrders.slice';
import { currentOrderReducer } from './orders/currentOrder.slice';
import { placeOrderReducer } from './orders/placeOrder.slice';
import { userReducer } from './user/user.slice';

import type { TIngredient } from '@utils-types';

const CONSTRUCTOR_LS_KEY = 'sb:constructor';

type StoredConstructorItem = TIngredient & { uuid: string };
interface StoredConstructorState {
  bun: TIngredient | null;
  ingredients: StoredConstructorItem[];
}

function normalizeConstructorState(raw: unknown): StoredConstructorState {
  if (raw && typeof raw === 'object' && 'bun' in raw && 'ingredients' in raw) {
    const typedRaw = raw as { bun: unknown; ingredients: unknown };

    const bun =
      typedRaw.bun && typeof typedRaw.bun === 'object' ? (typedRaw.bun as TIngredient) : null;

    const srcItems = Array.isArray(typedRaw.ingredients) ? typedRaw.ingredients : [];
    const ingredients: StoredConstructorItem[] = srcItems.map((rawItem: unknown, idx: number) => {
      if (rawItem && typeof rawItem === 'object' && '_id' in rawItem) {
        const base = rawItem as TIngredient & Partial<StoredConstructorItem>;
        const hasUuid = typeof (base as { uuid?: unknown }).uuid === 'string';
        const uuid = hasUuid ? (base as { uuid: string }).uuid : `m-${base._id}-${idx}-${nanoid()}`;
        return {
          _id: base._id,
          name: base.name,
          type: base.type,
          proteins: base.proteins ?? 0,
          fat: base.fat ?? 0,
          carbohydrates: base.carbohydrates ?? 0,
          calories: base.calories ?? 0,
          price: base.price ?? 0,
          image: base.image ?? '',
          image_mobile: base.image_mobile ?? '',
          image_large: base.image_large ?? '',
          uuid,
        };
      }
      return {
        _id: nanoid(),
        name: 'Unknown ingredient',
        type: 'main',
        proteins: 0,
        fat: 0,
        carbohydrates: 0,
        calories: 0,
        price: 0,
        image: '',
        image_mobile: '',
        image_large: '',
        uuid: nanoid(),
      };
    });

    return { bun, ingredients };
  }

  return { bun: null, ingredients: [] };
}

function loadConstructorFromLS(): StoredConstructorState | undefined {
  try {
    const raw = localStorage.getItem(CONSTRUCTOR_LS_KEY);
    if (!raw) return undefined;
    const parsed = JSON.parse(raw);
    return normalizeConstructorState(parsed);
  } catch {
    return undefined;
  }
}

function saveConstructorToLS(state: StoredConstructorState) {
  try {
    localStorage.setItem(CONSTRUCTOR_LS_KEY, JSON.stringify(state));
  } catch {}
}

function throttle<T extends (...args: unknown[]) => void>(fn: T, wait = 300): T {
  let last = 0;
  return function (this: unknown, ...args: unknown[]) {
    const now = Date.now();
    if (now - last >= wait) {
      last = now;
      fn.apply(this, args);
    }
  } as T;
}

const rootReducer = combineReducers({
  constructor: constructorReducer,
  ingredients: ingredientsReducer,
  publicOrders: publicOrdersReducer,
  userOrders: userOrdersReducer,
  currentOrder: currentOrderReducer,
  placeOrder: placeOrderReducer,
  user: userReducer,
});

const constructorInitial = constructorReducer(undefined, { type: '@@INIT' });
const stored = loadConstructorFromLS();
const hydratedConstructor = stored
  ? {
      ...constructorInitial,
      bun: stored.bun ?? constructorInitial.bun,
      ingredients: stored.ingredients ?? constructorInitial.ingredients,
    }
  : constructorInitial;

export const store = configureStore({
  reducer: rootReducer,
  preloadedState: {
    constructor: hydratedConstructor,
  },
  devTools: process.env.NODE_ENV !== 'production',
});

store.subscribe(
  throttle(() => {
    const state = store.getState();
    const { bun, ingredients } = state.constructor;
    saveConstructorToLS({ bun, ingredients });
  }, 300),
);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export const useAppDispatch: () => AppDispatch = useReduxDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useReduxSelector;

export default store;
